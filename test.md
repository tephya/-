# 附录  
## 预习报告  
### 项目3：基于共享内存的进程间通信——读者写者缓冲区问题

---

#### 一、实验目的

本实验通过模拟“1个读者和N个写者”对共享缓冲区的读写过程，加深对操作系统中进程间通信（IPC）、进程同步与互斥机制的理解。实验内容涵盖典型的生产者-消费者模型，重点掌握信号量、互斥锁等同步原语在并发环境下的正确用法。具体目标包括：

- 理解并掌握进程间通信及同步的基本原理；
- 熟悉信号量、互斥锁等同步机制的使用方法；
- 能够编程实现多进程/多线程协作访问共享资源时的数据一致性保障；
- 提升分析和解决并发程序中同步与互斥问题的能力。

---

#### 二、实验内容与要求

1. **实验内容**
   - 在Windows环境下，模拟1个读者和N个写者（N>1）对一个共享缓冲区的随机读写过程；
   - 缓冲区“非满”时允许连续写入（满时写者需等待），缓冲区“非空”时允许连续读取（空时读者需等待）；
   - 读写顺序交替，数据按写入顺序被读出，每个数据读出后缓冲区该单元空闲，等待新数据写入；
   - 实验过程需可视化显示读者和写者的数据读写过程。

2. **实验要求**
   - 当两个进程通信时，必须实现进程同步机制，确保数据正确交换与一致性；
   - 多进程通信（一个读者，多个写者）下，需采用信号量（或等价机制）实现互斥操作，防止竞态条件和数据冲突；
   - 编程语言不限，推荐支持多线程/多进程与同步原语的现代语言（如C++、Java、Python等）；
   - 程序应能动态展示缓冲区状态与各进程操作过程，便于观察同步/互斥效果。

---

#### 三、实验流程与实现方法

1. **数据结构设计**
   - 共享缓冲区采用循环队列或数组结构，包含定长数据单元；
   - 每个数据项包含写者编号、数据值、写入时间戳等信息；
   - 设计互斥锁（mutex）、信号量（如notFull、notEmpty）等同步原语，保护缓冲区的并发访问。

2. **进程/线程设计**
   - N个写者线程，每个线程随机生成数据并尝试写入缓冲区，缓冲区满时等待notFull信号；
   - 1个读者线程，循环尝试读取数据，缓冲区空时等待notEmpty信号；
   - 写入与读取操作均需加锁保护，保证操作的原子性和缓冲区状态正确更新。

3. **同步与互斥实现**
   - 写者写入时获得互斥锁，检查缓冲区是否满，写入后释放锁并唤醒读者；
   - 读者读取时获得互斥锁，检查缓冲区是否空，读取后释放锁并唤醒写者；
   - 采用条件变量或信号量机制协调空闲/占用单元的切换，防止死锁和忙等。

4. **可视化与实验观测**
   - 实时显示缓冲区内容、读写操作日志、各线程状态等；
   - 支持线程暂停/恢复，便于观察同步机制在不同场景下的作用。

---

#### 四、遇到的问题与思考

- 多线程/多进程环境下的同步与互斥细节繁多，容易出现死锁、竞态等问题，需特别关注锁的粒度和信号量的正确使用；
- 线程终止或缓冲区销毁时需唤醒阻塞线程，避免资源泄漏和“假死”；
- 随着写者数量和缓冲区大小增加，程序的并发性和可控性需通过合理设计同步策略加以保障；
- 实验需兼顾性能与正确性，避免忙等待，提高并发效率与响应能力。

---

（本报告内容结构参考前两项实验报告，并结合本实验代码实现要点与实验要求整理编写。）
